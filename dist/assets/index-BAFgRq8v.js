(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const a of n)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function t(n){const a={};return n.integrity&&(a.integrity=n.integrity),n.referrerPolicy&&(a.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?a.credentials="include":n.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(n){if(n.ep)return;n.ep=!0;const a=t(n);fetch(n.href,a)}})();class d{constructor(e,t){this.fallbackAction=t,this.combos=[...e].sort((s,n)=>n.sequence.length-s.sequence.length)}parseCombo(e){for(const t of this.combos)if(this.matchesSequence(e,t.sequence))return t;return this.fallbackAction}matchesSequence(e,t){if(e.length<t.length)return!1;for(let s=0;s<t.length;s++)if(e[s]!==t[s])return!1;return!0}findPotentialCombos(e){return this.combos.filter(t=>{if(e.length>t.sequence.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t.sequence[s])return!1;return!0})}getAllCombos(){return[...this.combos]}}class m{resolveTargets(e,t,s){switch(e){case"SINGLE_ENEMY":return this.selectSingleEnemy(t,s);case"ALL_ENEMIES":return this.getAllEnemies(t,s);case"RANDOM_ENEMY":return this.selectRandomEnemy(t,s);case"SELF":return[t];case"ALL_ALLIES":return this.getAllAllies(t,s);default:throw new Error(`Unknown targeting mode: ${e}`)}}selectSingleEnemy(e,t){if(e.team==="player"){const s=t.enemies.filter(n=>n.isAlive);return s.length>0?[s[0]]:[]}else return t.player.isAlive?[t.player]:[]}getAllEnemies(e,t){return e.team==="player"?t.enemies.filter(s=>s.isAlive):[t.player].filter(s=>s.isAlive)}selectRandomEnemy(e,t){if(e.team==="player"){const s=t.enemies.filter(a=>a.isAlive);if(s.length===0)return[];const n=Math.floor(Math.random()*s.length);return[s[n]]}else return t.player.isAlive?[t.player]:[]}getAllAllies(e,t){return e.team==="player"?[t.player].filter(s=>s.isAlive):t.enemies.filter(s=>s.isAlive)}}class f{constructor(e){this.statusRegistry=new Map(e.map(t=>[t.id,t]))}applyDamage(e,t,s,n,a){let i=0;const o=[];for(let u=0;u<a;u++){let l=e;l=this.applyOutgoingModifiers(l,s),t&&(l=this.applyElementalModifier(l,t,n)),l=this.applyIncomingModifiers(l,n),l=Math.round(l);const c=this.applyToEntity(l,n);i+=c.damageDealt,o.push(`Hit ${u+1}: ${c.damageDealt} damage (${c.shieldDamage} to shield, ${c.hpDamage} to HP)`)}return{totalDamage:i,breakdown:o,targetKilled:n.currentHp<=0}}applyOutgoingModifiers(e,t){let s=1;const n=t.statuses.find(a=>a.statusId==="weak");if(n){const a=this.statusRegistry.get("weak");if(a!=null&&a.effectPerStack.outgoingDamageMultiplier){const i=a.effectPerStack.outgoingDamageMultiplier;s*=Math.pow(i,n.stacks)}}return e*s}applyElementalModifier(e,t,s){const n=s.elementalAffinities[t]||1;return e*n}applyIncomingModifiers(e,t){let s=1;const n=t.statuses.find(a=>a.statusId==="vulnerable");if(n){const a=this.statusRegistry.get("vulnerable");if(a!=null&&a.effectPerStack.damageMultiplier){const i=a.effectPerStack.damageMultiplier;s*=Math.pow(i,n.stacks)}}return e*s}applyToEntity(e,t){let s=e,n=0,a=0;return t.shield>0&&(n=Math.min(s,t.shield),t.shield-=n,s-=n),s>0&&(a=Math.min(s,t.currentHp),t.currentHp-=a),t.currentHp<=0&&(t.currentHp=0,t.isAlive=!1),{damageDealt:n+a,shieldDamage:n,hpDamage:a}}}class h{constructor(e){this.statusRegistry=new Map(e.map(t=>[t.id,t]))}applyStatus(e,t,s){const n=e.statuses.find(a=>a.statusId===t);if(n?n.stacks+=s:e.statuses.push({statusId:t,stacks:s}),t==="shield"){const a=this.statusRegistry.get("shield");if(a!=null&&a.effectPerStack.shieldPerStack){const i=a.effectPerStack.shieldPerStack*s;e.shield+=i}}}triggerStatusEffects(e,t){const s=[];for(const n of e.statuses){const a=this.statusRegistry.get(n.statusId);if(!a||a.triggerTiming!==t)continue;const i=this.executeStatusEffect(e,a,n.stacks);i&&s.push(i)}return s}executeStatusEffect(e,t,s){const n=t.effectPerStack;if(n.damagePerStack){const a=n.damagePerStack*s;return e.currentHp=Math.max(0,e.currentHp-a),e.currentHp<=0&&(e.isAlive=!1),{entityId:e.id,statusName:t.name,effect:`${a} ${t.name} damage`,killed:!e.isAlive}}if(n.healPerStack){const a=n.healPerStack*s,i=Math.min(a,e.maxHp-e.currentHp);return e.currentHp+=i,{entityId:e.id,statusName:t.name,effect:`${i} HP restored`,killed:!1}}return n.preventAction&&s>0?{entityId:e.id,statusName:t.name,effect:"Action prevented",killed:!1}:null}decayStatuses(e){e.statuses=e.statuses.map(t=>{const s=this.statusRegistry.get(t.statusId);return s?{...t,stacks:Math.max(0,t.stacks-s.decayPerTurn)}:t}).filter(t=>t.stacks>0)}isStunned(e){const t=e.statuses.find(s=>s.statusId==="stun");return t!==void 0&&t.stacks>0}getStatusDefinition(e){return this.statusRegistry.get(e)}}class g{constructor(e){this.actionRegistry=new Map(e.map(t=>[t.id,t]))}selectAction(e,t){const s=e.actionPool.map(a=>this.actionRegistry.get(a)).filter(a=>a!==void 0);if(s.length===0)throw new Error(`Enemy ${e.id} has no valid actions!`);const n=Math.floor(Math.random()*s.length);return s[n]}selectActionByPattern(e,t,s){const n=e.actionPool.map(a=>this.actionRegistry.get(a)).filter(a=>a!==void 0);if(n.length===0)throw new Error(`Enemy ${e.id} has no valid actions!`);switch(t.strategy){case"RANDOM":return n[Math.floor(Math.random()*n.length)];case"SEQUENTIAL":const a=s.turnCount%n.length;return n[a];case"CONDITIONAL":return e.currentHp/e.maxHp<.3&&n.find(u=>u.statusEffects.some(l=>l.statusId==="shield"||l.statusId==="regen"))||n[0];default:return n[0]}}getAction(e){return this.actionRegistry.get(e)}}class p{constructor(e,t,s,n){this.fallbackAction=n,this.comboParser=new d(e,n),this.targetResolver=new m,this.damageResolver=new f(t),this.statusManager=new h(t),this.enemyAI=new g(s)}executePlayerTurn(e){const t=this.comboParser.parseCombo(e.inputBuffer);return t.id!==this.fallbackAction.id&&(e.lastSuccessfulCombo=[...t.sequence]),e.combatLog.push({timestamp:Date.now(),message:`Player used: ${t.name}`,type:"combo"}),this.executeAction(e.player,t,e),e.inputBuffer=[],e.enemies.every(s=>!s.isAlive)?(e.isVictory=!0,e.turnPhase="COMBAT_END",e):(e.turnPhase="ENEMY_TURN",e)}executeEnemyTurns(e){for(const t of e.enemies){if(!t.isAlive)continue;if(this.statusManager.isStunned(t)){e.combatLog.push({timestamp:Date.now(),message:`${t.name} is stunned and cannot act!`,type:"status"});continue}const s=this.enemyAI.selectAction(t,e);if(e.combatLog.push({timestamp:Date.now(),message:`${t.name} used: ${s.name}`,type:"action"}),this.executeAction(t,s,e),!e.player.isAlive)return e.isDefeat=!0,e.turnPhase="COMBAT_END",e}return e.turnPhase="TURN_END",e}executeTurnEnd(e){const t=[e.player,...e.enemies];for(const s of t){if(!s.isAlive)continue;const n=this.statusManager.triggerStatusEffects(s,"TURN_END");for(const a of n)e.combatLog.push({timestamp:Date.now(),message:`${s.name}: ${a.effect}`,type:"status"}),a.killed&&e.combatLog.push({timestamp:Date.now(),message:`${s.name} has died!`,type:"death"})}for(const s of t)this.statusManager.decayStatuses(s);if(e.enemies.every(s=>!s.isAlive))return e.isVictory=!0,e.turnPhase="COMBAT_END",e;if(!e.player.isAlive)return e.isDefeat=!0,e.turnPhase="COMBAT_END",e;e.turnCount++,e.turnPhase="PLAYER_INPUT";for(const s of t){if(!s.isAlive)continue;const n=this.statusManager.triggerStatusEffects(s,"TURN_START");for(const a of n)e.combatLog.push({timestamp:Date.now(),message:`${s.name}: ${a.effect}`,type:"status"})}return e}executeAction(e,t,s){const n=this.targetResolver.resolveTargets(t.targeting,e,s);if(n.length===0){s.combatLog.push({timestamp:Date.now(),message:`${t.name} had no valid targets!`,type:"action"});return}for(const a of n){if(t.damage>0){const i=this.damageResolver.applyDamage(t.damage,t.element,e,a,t.hitCount);s.combatLog.push({timestamp:Date.now(),message:`${a.name} took ${i.totalDamage} damage!`,type:"damage"}),i.targetKilled&&s.combatLog.push({timestamp:Date.now(),message:`${a.name} has died!`,type:"death"})}for(const i of t.statusEffects){const o=i.target==="self"?e:a;this.statusManager.applyStatus(o,i.statusId,i.stacks),s.combatLog.push({timestamp:Date.now(),message:`${o.name} gained ${i.stacks} stacks of ${i.statusId}`,type:"status"})}}}}class E{constructor(e=20){this.buffer=[],this.maxBufferSize=e}addInput(e){this.buffer.push(e),this.buffer.length>this.maxBufferSize&&this.buffer.shift()}getBuffer(){return[...this.buffer]}clearBuffer(){this.buffer=[]}removeLastInput(){return this.buffer.pop()}setBuffer(e){this.buffer=[...e]}getLength(){return this.buffer.length}isEmpty(){return this.buffer.length===0}}class I{constructor(e,t,s,n,a){this.state=e,this.turnManager=new p(t,s,n,a),this.inputBuffer=new E}addInput(e){if(this.state.turnPhase!=="PLAYER_INPUT"){console.warn("Not in player input phase");return}this.inputBuffer.addInput(e),this.state.inputBuffer=this.inputBuffer.getBuffer()}undoLastInput(){if(this.state.turnPhase!=="PLAYER_INPUT"){console.warn("Not in player input phase");return}this.inputBuffer.removeLastInput(),this.state.inputBuffer=this.inputBuffer.getBuffer()}clearInput(){if(this.state.turnPhase!=="PLAYER_INPUT"){console.warn("Not in player input phase");return}this.inputBuffer.clearBuffer(),this.state.inputBuffer=this.inputBuffer.getBuffer()}confirmAction(){if(this.state.turnPhase!=="PLAYER_INPUT"){console.warn("Not in player input phase");return}this.state.turnPhase="PLAYER_EXECUTING",this.state=this.turnManager.executePlayerTurn(this.state),this.inputBuffer.clearBuffer(),this.progressTurn()}replayLastCombo(){if(!this.state.lastSuccessfulCombo){console.warn("No combo to replay");return}if(this.state.turnPhase!=="PLAYER_INPUT"){console.warn("Not in player input phase");return}this.inputBuffer.setBuffer(this.state.lastSuccessfulCombo),this.state.inputBuffer=this.inputBuffer.getBuffer(),this.confirmAction()}progressTurn(){for(;this.state.turnPhase!=="PLAYER_INPUT"&&this.state.turnPhase!=="COMBAT_END";)switch(this.state.turnPhase){case"ENEMY_TURN":this.state=this.turnManager.executeEnemyTurns(this.state);break;case"TURN_END":this.state=this.turnManager.executeTurnEnd(this.state);break}}getState(){return this.state}isCombatOver(){return this.state.isVictory||this.state.isDefeat}getCombatResult(){return this.state.isVictory?"victory":this.state.isDefeat?"defeat":"ongoing"}}const y=[{id:"fireball",name:"Fireball",sequence:["UP","UP","RIGHT"],damage:30,element:"FIRE",targeting:"SINGLE_ENEMY",statusEffects:[{statusId:"burn",stacks:2,target:"target"}],hitCount:1},{id:"meteor_storm",name:"Meteor Storm",sequence:["UP","UP","RIGHT","DOWN","DOWN"],damage:50,element:"FIRE",targeting:"ALL_ENEMIES",statusEffects:[{statusId:"burn",stacks:3,target:"target"}],hitCount:3},{id:"flame_blade",name:"Flame Blade",sequence:["UP","RIGHT","DOWN"],damage:25,element:"FIRE",targeting:"SINGLE_ENEMY",statusEffects:[],hitCount:2},{id:"ice_shard",name:"Ice Shard",sequence:["DOWN","DOWN","UP"],damage:28,element:"ICE",targeting:"SINGLE_ENEMY",statusEffects:[{statusId:"stun",stacks:1,target:"target"}],hitCount:1},{id:"blizzard",name:"Blizzard",sequence:["DOWN","DOWN","UP","LEFT","LEFT"],damage:45,element:"ICE",targeting:"ALL_ENEMIES",statusEffects:[{statusId:"stun",stacks:1,target:"target"}],hitCount:2},{id:"lightning_bolt",name:"Lightning Bolt",sequence:["UP","DOWN","UP"],damage:35,element:"LIGHTNING",targeting:"RANDOM_ENEMY",statusEffects:[],hitCount:1},{id:"chain_lightning",name:"Chain Lightning",sequence:["UP","DOWN","UP","DOWN","UP"],damage:20,element:"LIGHTNING",targeting:"ALL_ENEMIES",statusEffects:[{statusId:"vulnerable",stacks:2,target:"target"}],hitCount:1},{id:"poison_dart",name:"Poison Dart",sequence:["LEFT","LEFT","RIGHT"],damage:15,element:"POISON",targeting:"SINGLE_ENEMY",statusEffects:[{statusId:"poison",stacks:5,target:"target"}],hitCount:1},{id:"toxic_cloud",name:"Toxic Cloud",sequence:["LEFT","LEFT","RIGHT","UP","DOWN"],damage:10,element:"POISON",targeting:"ALL_ENEMIES",statusEffects:[{statusId:"poison",stacks:3,target:"target"},{statusId:"weak",stacks:2,target:"target"}],hitCount:1},{id:"heal",name:"Regenerate",sequence:["DOWN","DOWN","LEFT"],damage:0,element:null,targeting:"SELF",statusEffects:[{statusId:"regen",stacks:5,target:"self"}],hitCount:1},{id:"shield",name:"Magic Shield",sequence:["LEFT","DOWN","RIGHT"],damage:0,element:null,targeting:"SELF",statusEffects:[{statusId:"shield",stacks:3,target:"self"}],hitCount:1},{id:"berserker",name:"Berserker Rage",sequence:["RIGHT","RIGHT","RIGHT"],damage:60,element:"PHYSICAL",targeting:"SINGLE_ENEMY",statusEffects:[{statusId:"vulnerable",stacks:3,target:"self"}],hitCount:1},{id:"slash",name:"Slash",sequence:["RIGHT","LEFT"],damage:20,element:"PHYSICAL",targeting:"SINGLE_ENEMY",statusEffects:[],hitCount:1},{id:"whirlwind",name:"Whirlwind",sequence:["RIGHT","LEFT","RIGHT","LEFT"],damage:18,element:"PHYSICAL",targeting:"ALL_ENEMIES",statusEffects:[],hitCount:2}],S={id:"weak_attack",name:"Weak Attack",sequence:[],damage:5,element:"PHYSICAL",targeting:"SINGLE_ENEMY",statusEffects:[],hitCount:1},L=[{id:"burn",name:"Burn",type:"DAMAGE_OVER_TIME",triggerTiming:"TURN_END",effectPerStack:{damagePerStack:3},decayPerTurn:1},{id:"poison",name:"Poison",type:"DAMAGE_OVER_TIME",triggerTiming:"TURN_START",effectPerStack:{damagePerStack:5},decayPerTurn:1},{id:"bleed",name:"Bleed",type:"DAMAGE_OVER_TIME",triggerTiming:"TURN_END",effectPerStack:{damagePerStack:4},decayPerTurn:2},{id:"regen",name:"Regeneration",type:"BUFF",triggerTiming:"TURN_START",effectPerStack:{healPerStack:4},decayPerTurn:1},{id:"shield",name:"Shield",type:"BUFF",triggerTiming:"PASSIVE",effectPerStack:{shieldPerStack:10},decayPerTurn:0},{id:"vulnerable",name:"Vulnerable",type:"DEBUFF",triggerTiming:"ON_HIT_TAKEN",effectPerStack:{damageMultiplier:1.2},decayPerTurn:1},{id:"weak",name:"Weak",type:"DEBUFF",triggerTiming:"ON_HIT_DEALT",effectPerStack:{outgoingDamageMultiplier:.9},decayPerTurn:1},{id:"stun",name:"Stun",type:"CONTROL",triggerTiming:"PASSIVE",effectPerStack:{preventAction:!0},decayPerTurn:1}],P=[{id:"claw_swipe",name:"Claw Swipe",damage:15,element:"PHYSICAL",targeting:"SINGLE_ENEMY",statusEffects:[],hitCount:1},{id:"bite",name:"Bite",damage:20,element:"PHYSICAL",targeting:"SINGLE_ENEMY",statusEffects:[{statusId:"bleed",stacks:2,target:"target"}],hitCount:1},{id:"tail_sweep",name:"Tail Sweep",damage:8,element:"PHYSICAL",targeting:"ALL_ENEMIES",statusEffects:[],hitCount:1},{id:"charge",name:"Charge",damage:25,element:"PHYSICAL",targeting:"SINGLE_ENEMY",statusEffects:[],hitCount:1},{id:"poison_spit",name:"Poison Spit",damage:10,element:"POISON",targeting:"SINGLE_ENEMY",statusEffects:[{statusId:"poison",stacks:3,target:"target"}],hitCount:1},{id:"fire_breath",name:"Fire Breath",damage:18,element:"FIRE",targeting:"ALL_ENEMIES",statusEffects:[{statusId:"burn",stacks:2,target:"target"}],hitCount:1},{id:"ice_beam",name:"Ice Beam",damage:22,element:"ICE",targeting:"SINGLE_ENEMY",statusEffects:[{statusId:"stun",stacks:1,target:"target"}],hitCount:1},{id:"lightning_strike",name:"Lightning Strike",damage:30,element:"LIGHTNING",targeting:"RANDOM_ENEMY",statusEffects:[],hitCount:1},{id:"weakening_howl",name:"Weakening Howl",damage:5,element:null,targeting:"ALL_ENEMIES",statusEffects:[{statusId:"weak",stacks:3,target:"target"}],hitCount:1},{id:"intimidate",name:"Intimidate",damage:0,element:null,targeting:"ALL_ENEMIES",statusEffects:[{statusId:"vulnerable",stacks:2,target:"target"}],hitCount:1},{id:"harden",name:"Harden",damage:0,element:null,targeting:"SELF",statusEffects:[{statusId:"shield",stacks:2,target:"self"}],hitCount:1},{id:"regenerate",name:"Regenerate",damage:0,element:null,targeting:"SELF",statusEffects:[{statusId:"regen",stacks:4,target:"self"}],hitCount:1},{id:"fury_swipes",name:"Fury Swipes",damage:8,element:"PHYSICAL",targeting:"SINGLE_ENEMY",statusEffects:[],hitCount:3},{id:"double_strike",name:"Double Strike",damage:12,element:"PHYSICAL",targeting:"SINGLE_ENEMY",statusEffects:[],hitCount:2}];function N(){return{player:{id:"player",name:"Hero",maxHp:100,currentHp:100,shield:0,statuses:[],elementalAffinities:{FIRE:1,ICE:1,LIGHTNING:.5,POISON:1,PHYSICAL:1},isAlive:!0,team:"player"},enemies:[{id:"goblin_1",name:"Goblin Warrior",maxHp:50,currentHp:50,shield:0,statuses:[],elementalAffinities:{FIRE:1.5,ICE:1,LIGHTNING:1,POISON:.5,PHYSICAL:1},isAlive:!0,team:"enemy",aiPatternId:"basic",actionPool:["claw_swipe","bite","weakening_howl"]},{id:"slime_1",name:"Toxic Slime",maxHp:30,currentHp:30,shield:0,statuses:[],elementalAffinities:{FIRE:2,ICE:.5,LIGHTNING:1,POISON:0,PHYSICAL:.8},isAlive:!0,team:"enemy",aiPatternId:"basic",actionPool:["poison_spit","tail_sweep"]}],turnPhase:"PLAYER_INPUT",turnCount:1,inputBuffer:[],lastSuccessfulCombo:null,combatLog:[],isVictory:!1,isDefeat:!1}}class A{constructor(e){this.controller=e,this.elements=this.initializeElements(),this.attachEventListeners(),this.render()}initializeElements(){return{turnCount:document.getElementById("turnCount"),turnPhase:document.getElementById("turnPhase"),playerCard:document.getElementById("playerCard"),playerName:document.getElementById("playerName"),playerHpText:document.getElementById("playerHpText"),playerHpBar:document.getElementById("playerHpBar"),playerShieldContainer:document.getElementById("playerShieldContainer"),playerShieldText:document.getElementById("playerShieldText"),playerShieldBar:document.getElementById("playerShieldBar"),playerStatuses:document.getElementById("playerStatuses"),enemyContainer:document.getElementById("enemyContainer"),inputDisplay:document.getElementById("inputDisplay"),combatLog:document.getElementById("combatLog"),victoryBanner:document.getElementById("victoryBanner"),defeatBanner:document.getElementById("defeatBanner"),confirmBtn:document.getElementById("confirmBtn"),clearBtn:document.getElementById("clearBtn"),replayBtn:document.getElementById("replayBtn"),dirBtns:document.querySelectorAll(".dir-btn")}}attachEventListeners(){this.elements.dirBtns.forEach(e=>{e.addEventListener("click",()=>{if(!this.controller.isCombatOver()){const t=e.dataset.dir;this.controller.addInput(t),this.render()}})}),this.elements.clearBtn.addEventListener("click",()=>{this.controller.clearInput(),this.render()}),this.elements.confirmBtn.addEventListener("click",()=>{!this.controller.isCombatOver()&&this.controller.getState().inputBuffer.length>0&&(this.animateHit(),this.controller.confirmAction(),this.render())}),this.elements.replayBtn.addEventListener("click",()=>{!this.controller.isCombatOver()&&this.controller.getState().lastSuccessfulCombo&&(this.animateHit(),this.controller.replayLastCombo(),this.render())}),document.addEventListener("keydown",e=>{if(this.controller.isCombatOver())return;const t={ArrowUp:"UP",ArrowDown:"DOWN",ArrowLeft:"LEFT",ArrowRight:"RIGHT",w:"UP",s:"DOWN",a:"LEFT",d:"RIGHT"};t[e.key]?(e.preventDefault(),this.controller.addInput(t[e.key]),this.render()):e.key==="Enter"?(e.preventDefault(),this.elements.confirmBtn.click()):e.key==="Escape"?(e.preventDefault(),this.elements.clearBtn.click()):(e.key==="r"||e.key==="R")&&(e.preventDefault(),this.elements.replayBtn.click())})}animateHit(){this.controller.getState().enemies.forEach(t=>{if(t.isAlive){const s=document.getElementById(t.id);s&&(s.classList.add("hit"),setTimeout(()=>s.classList.remove("hit"),500))}})}render(){const e=this.controller.getState();this.renderTurnInfo(e),this.renderPlayer(e.player),this.renderEnemies(e.enemies),this.renderInputBuffer(e.inputBuffer),this.renderCombatLog(e.combatLog),this.renderCombatStatus(e),this.updateButtonStates(e)}renderTurnInfo(e){this.elements.turnCount.textContent=e.turnCount.toString(),this.elements.turnPhase.textContent=e.turnPhase==="PLAYER_INPUT"?"Player's Turn":"Enemy Turn"}renderPlayer(e){this.elements.playerName.textContent=e.name,this.elements.playerHpText.textContent=`${e.currentHp} / ${e.maxHp}`;const t=e.currentHp/e.maxHp*100;if(this.elements.playerHpBar.style.width=`${t}%`,e.isAlive?this.elements.playerCard.classList.remove("dead"):this.elements.playerCard.classList.add("dead"),e.shield>0){this.elements.playerShieldContainer.style.display="block",this.elements.playerShieldText.textContent=e.shield.toString();const s=e.shield/50*100;this.elements.playerShieldBar.style.width=`${s}%`}else this.elements.playerShieldContainer.style.display="none";this.renderStatuses(this.elements.playerStatuses,e.statuses)}renderEnemies(e){this.elements.enemyContainer.innerHTML="",e.forEach(t=>{const s=document.createElement("div");s.className="entity-card",s.id=t.id,t.isAlive||s.classList.add("dead");const n=t.currentHp/t.maxHp*100;s.innerHTML=`
        <div class="entity-name">${t.name}</div>
        <div class="hp-container">
          <div class="hp-label">
            <span>HP</span>
            <span>${t.currentHp} / ${t.maxHp}</span>
          </div>
          <div class="hp-bar">
            <div class="hp-fill" style="width: ${n}%"></div>
          </div>
        </div>
        <div class="status-list" id="status-${t.id}"></div>
      `,this.elements.enemyContainer.appendChild(s);const a=document.getElementById(`status-${t.id}`);a&&this.renderStatuses(a,t.statuses)})}renderStatuses(e,t){e.innerHTML="",t.forEach(s=>{const n=document.createElement("div");n.className=`status-badge ${s.type}`,n.textContent=`${s.type} (${s.duration})`,e.appendChild(n)})}renderInputBuffer(e){if(this.elements.inputDisplay.innerHTML="",e.length===0)this.elements.inputDisplay.innerHTML='<span style="opacity: 0.5; font-style: italic;">Use arrow buttons below...</span>';else{const t={UP:"▲",DOWN:"▼",LEFT:"◀",RIGHT:"▶"};e.forEach(s=>{const n=document.createElement("div");n.className="input-arrow",n.textContent=t[s],this.elements.inputDisplay.appendChild(n)})}}renderCombatLog(e){this.elements.combatLog.innerHTML="",e.slice(-20).forEach(s=>{const n=document.createElement("div");n.className=`log-entry ${s.type}`,n.textContent=s.message,this.elements.combatLog.appendChild(n)}),this.elements.combatLog.scrollTop=this.elements.combatLog.scrollHeight}renderCombatStatus(e){e.isVictory?this.elements.victoryBanner.classList.add("show"):e.isDefeat&&this.elements.defeatBanner.classList.add("show")}updateButtonStates(e){const t=this.controller.isCombatOver(),s=e.inputBuffer.length>0,n=e.lastSuccessfulCombo!==null;this.elements.dirBtns.forEach(a=>{a.disabled=t}),this.elements.confirmBtn.disabled=t||!s,this.elements.clearBtn.disabled=t,this.elements.replayBtn.disabled=t||!n}}document.addEventListener("DOMContentLoaded",()=>{const r=N(),e=new I(r,y,L,P,S);new A(e)});
